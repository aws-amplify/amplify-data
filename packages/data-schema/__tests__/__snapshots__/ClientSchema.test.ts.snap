// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`custom operations custom mutation 1`] = `
"type LikePostResult 
{
  likes: Int!
}

type Mutation {
  likePost(postId: String!): LikePostResult @function(name: "likePost") @auth(rules: [{allow: public}])
}"
`;

exports[`custom operations custom query 1`] = `
"type EchoResult 
{
  resultContent: String
}

type Query {
  echo(inputContent: String!): EchoResult @function(name: "echoFunction") @auth(rules: [{allow: public}])
}"
`;

exports[`schema auth rules allows custom 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: custom}])
{
  id: ID! @primaryKey
  field: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules allows groupDefinedIn 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "someField"}])
{
  id: ID! @primaryKey
  field: String
  someField: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules allows groupsDefinedIn 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: groups, groupsField: "someField"}])
{
  id: ID! @primaryKey
  field: String
  someField: [String]
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules allows multiple entries 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: public},
  {allow: private}])
{
  id: ID! @primaryKey
  field: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules allows multipleOwners 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  id: ID! @primaryKey
  field: String
  owner: [String]
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules allows owner 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  id: ID! @primaryKey
  field: String
  owner: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules allows private 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: private}])
{
  id: ID! @primaryKey
  field: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules allows public 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  field: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules allows specificGroups 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: groups, groups: ["a", "b"]}])
{
  id: ID! @primaryKey
  field: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules can define public auth with no provider 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  field: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}"
`;

exports[`schema auth rules disallows specificGroup 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: groups, groups: ["group"]}])
{
  id: ID! @primaryKey
  field: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules do not pullote custom operations 1`] = `
{
  "functionSlots": [],
  "schema": "type Post @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  id: ID! @primaryKey
  title: String
  owner: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Mutation {
  likePost(postId: String): Post 
}

type Query {
  getLikedPost: Post 
}

type Subscription {
  onLikePost: Post 
}",
}
`;

exports[`schema auth rules global public auth - multiple models 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  field: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type B @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  field: AWSJSON
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type C @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  d: D @hasOne
  cDId: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type D @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  can: Int
  you: Boolean
  tell: Float
  i: AWSDate
  am: AWSIPAddress
  getting: AWSURL
  tired: Tired
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

enum Tired {
  ?
}",
}
`;

exports[`schema auth rules prefers model auth over global auth owner auth on model vs owner auth on schema 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "modelOwnerField"}])
{
  id: ID! @primaryKey
  field: String
  modelOwnerField: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules prefers model auth over global auth owner auth on model vs public auth on schema 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  id: ID! @primaryKey
  field: String
  owner: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema auth rules prefers model auth over global auth public auth on model vs owner auth on schema 1`] = `
{
  "functionSlots": [],
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  field: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}",
}
`;

exports[`schema generation with relationships 1`] = `
"type BoringParent @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  childNormal: BoringChild @hasOne
  childReciprocal: BoringReciprocalChild @hasOne
  childHasManyNormal: [BoringHasManyChild] @hasMany
  childHasManyReciprocal: [ReciprocalHasManyChild] @hasMany
  boringParentChildNormalId: ID
  boringParentChildReciprocalId: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type BoringChild @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  value: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type BoringReciprocalChild @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  parent: BoringParent @belongsTo
  value: String
  boringReciprocalChildParentId: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type BoringHasManyChild @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  value: String
  boringParentChildHasManyNormalId: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type ReciprocalHasManyChild @model @auth(rules: [{allow: public}])
{
  id: ID! @primaryKey
  value: String
  parent: BoringParent @belongsTo
  boringParentChildHasManyReciprocalId: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type CPKParent @model @auth(rules: [{allow: public}])
{
  CPKParentIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKParentIdFieldB"])
  CPKParentIdFieldB: ID!
  childNormal: CPKChild @hasOne
  childReciprocal: CPKReciprocalChild @hasOne
  childHasManyNormal: [CPKHasManyChild] @hasMany
  childHasManyReciprocal: [CPKReciprocalHasManyChild] @hasMany
  cPKParentChildNormalCPKChildIdFieldA: ID
  cPKParentChildNormalCPKChildIdFieldB: ID
  cPKParentChildReciprocalCPKReciprocalChildIdFieldA: ID
  cPKParentChildReciprocalCPKReciprocalChildIdFieldB: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type CPKChild @model @auth(rules: [{allow: public}])
{
  CPKChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKChildIdFieldB"])
  CPKChildIdFieldB: ID!
  value: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type CPKReciprocalChild @model @auth(rules: [{allow: public}])
{
  CPKReciprocalChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKReciprocalChildIdFieldB"])
  CPKReciprocalChildIdFieldB: ID!
  parent: CPKParent @belongsTo
  value: String
  cPKReciprocalChildParentCPKParentIdFieldA: ID
  cPKReciprocalChildParentCPKParentIdFieldB: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type CPKHasManyChild @model @auth(rules: [{allow: public}])
{
  CPKHasManyChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKHasManyChildIdFieldB"])
  CPKHasManyChildIdFieldB: ID!
  value: String
  cPKParentChildHasManyNormalCPKParentIdFieldA: ID
  cPKParentChildHasManyNormalCPKParentIdFieldB: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type CPKReciprocalHasManyChild @model @auth(rules: [{allow: public}])
{
  CPKReciprocalHasManyChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKReciprocalHasManyChildIdFieldB"])
  CPKReciprocalHasManyChildIdFieldB: ID!
  value: String
  parent: CPKParent @belongsTo
  cPKParentChildHasManyReciprocalCPKParentIdFieldA: ID
  cPKParentChildHasManyReciprocalCPKParentIdFieldB: ID
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}"
`;
