// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`RDS Schema with sql statement references schema with full path sql reference 1`] = `
{
  "customSqlDataSourceStrategies": [
    {
      "entry": "/full/path/to/sql/statement/directory/testReferenceName",
      "fieldName": "callSql",
      "typeName": "Query",
    },
  ],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type widget @model @auth(rules: [{allow: public}])
{
  title: String!
  someOwnerField: String
}

type Query {
  callSql: widget @sql(reference: "/full/path/to/sql/statement/directory/testReferenceName") @auth(rules: [{allow: public}])
}",
}
`;

exports[`custom operations custom mutation 1`] = `
"type LikePostResult 
{
  likes: Int!
}

type Mutation {
  likePost(postId: String!): LikePostResult @function(name: "likePost") @auth(rules: [{allow: public}])
}"
`;

exports[`custom operations custom query 1`] = `
"type EchoResult 
{
  resultContent: String
}

type Query {
  echo(inputContent: String!): EchoResult @function(name: "echoFunction") @auth(rules: [{allow: public}])
}"
`;

exports[`custom operations for a.combine schema a ddb and sql schemas combine without issues 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  field: String
}
type B @model @auth(rules: [{allow: public}])
{
  field: String
}"
`;

exports[`custom operations for a.combine schema combining two schemas with custom mutation results in customTypes and customOperations that intersect the separate schemas 1`] = `
"type LikePostResult 
{
  likes: Int!
}

type A @model @auth(rules: [{allow: public}])
{
  fieldA: String
}

type Mutation {
  likePost(postId: String!): LikePostResult @function(name: "likePost") @auth(rules: [{allow: public}])
}
type DislikePostResult 
{
  likes: Int!
}

type B @model @auth(rules: [{allow: public}])
{
  fieldB: String
}

type Mutation {
  dislikePost(postId: String!): DislikePostResult @function(name: "dislikePost") @auth(rules: [{allow: public}])
}"
`;

exports[`custom operations for a.combine schema two schemas combine without issues 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  field: String
}
type B @model @auth(rules: [{allow: public}])
{
  field: String
}"
`;

exports[`custom operations for an rds schema can define public auth with no provider 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  field: String
}"
`;

exports[`custom operations for an rds schema custom operations custom query 1`] = `
"type EchoResult 
{
  resultContent: String
}

type Query {
  echo(inputContent: String!): EchoResult @function(name: "echoFunction") @auth(rules: [{allow: public}])
}"
`;

exports[`schema auth rules allows custom 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: custom}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows groupDefinedIn 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "someField"}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows groupsDefinedIn 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: groups, groupsField: "someField"}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows multiple entries 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public},
  {allow: private}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows multipleOwners 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows owner 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows private 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: private}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows public 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows specificGroups 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: groups, groups: ["a", "b"]}])
{
  field: String
}",
}
`;

exports[`schema auth rules can define public auth with no provider 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  field: String
}"
`;

exports[`schema auth rules disallows specificGroup 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: groups, groups: ["group"]}])
{
  field: String
}",
}
`;

exports[`schema auth rules do not pull out custom operations 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type Post @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  title: String
}

type Mutation {
  likePost(postId: String): Post @function(name: "myFunc") @auth(rules: [{allow: owner, ownerField: "owner"}])
}

type Query {
  getLikedPost: Post @function(name: "myFunc") @auth(rules: [{allow: owner, ownerField: "owner"}])
}

type Subscription {
  onLikePost: Post @function(name: "myFunc") @aws_subscribe(mutations: ["likePost"]) @auth(rules: [{allow: owner, ownerField: "owner"}])
}",
}
`;

exports[`schema auth rules global public auth - multiple models 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  field: String
}

type B @model @auth(rules: [{allow: public}])
{
  field: AWSJSON
}

type C @model @auth(rules: [{allow: public}])
{
  d: D @hasOne(references: ["cId"])
}

type D @model @auth(rules: [{allow: public}])
{
  can: Int
  you: Boolean
  tell: Float
  i: AWSDate
  am: AWSIPAddress
  getting: AWSURL
  tired: DTired
  cId: ID
  c: C @belongsTo(references: ["cId"])
}

enum DTired {
  ?
}",
}
`;

exports[`schema auth rules prefers model auth over global auth owner auth on model vs owner auth on schema 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "modelOwnerField"}])
{
  field: String
}",
}
`;

exports[`schema auth rules prefers model auth over global auth owner auth on model vs public auth on schema 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  field: String
}",
}
`;

exports[`schema auth rules prefers model auth over global auth public auth on model vs owner auth on schema 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  field: String
}",
}
`;

exports[`schema generation with relationships 1`] = `
"type BoringParent @model @auth(rules: [{allow: public}])
{
  childNormal: BoringChild @hasOne(references: ["boringParentId"])
  childReciprocal: BoringReciprocalChild @hasOne(references: ["boringParentId"])
  childHasManyNormal: [BoringHasManyChild] @hasMany(references: ["boringParentId"])
  childHasManyReciprocal: [ReciprocalHasManyChild] @hasMany(references: ["boringParentId"])
}

type BoringChild @model @auth(rules: [{allow: public}])
{
  value: String
  boringParentId: ID
  boringParent: BoringParent @belongsTo(references: ["boringParentId"])
}

type BoringReciprocalChild @model @auth(rules: [{allow: public}])
{
  value: String
  boringParentId: ID
  parent: BoringParent @belongsTo(references: ["boringParentId"])
}

type BoringHasManyChild @model @auth(rules: [{allow: public}])
{
  value: String
  boringParentId: ID
  parent: BoringParent @belongsTo(references: ["boringParentId"])
}

type ReciprocalHasManyChild @model @auth(rules: [{allow: public}])
{
  value: String
  boringParentId: ID
  parent: BoringParent @belongsTo(references: ["boringParentId"])
}

type CPKParent @model @auth(rules: [{allow: public}])
{
  CPKParentIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKParentIdFieldB"])
  CPKParentIdFieldB: ID!
  childNormal: CPKChild @hasOne(references: ["CPKParentIdFieldA","CPKParentIdFieldB"])
  childReciprocal: CPKReciprocalChild @hasOne(references: ["CPKParentIdFieldA","CPKParentIdFieldB"])
  childHasManyNormal: [CPKHasManyChild] @hasMany(references: ["CPKParentIdFieldA","CPKParentIdFieldB"])
  childHasManyReciprocal: [CPKReciprocalHasManyChild] @hasMany(references: ["CPKParentIdFieldA","CPKParentIdFieldB"])
}

type CPKChild @model @auth(rules: [{allow: public}])
{
  value: String
  CPKChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKChildIdFieldB"])
  CPKChildIdFieldB: ID!
  CPKParentIdFieldA: ID
  CPKParentIdFieldB: ID
  cpkParent: CPKParent @belongsTo(references: ["CPKParentIdFieldA","CPKParentIdFieldB"])
}

type CPKReciprocalChild @model @auth(rules: [{allow: public}])
{
  CPKReciprocalChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKReciprocalChildIdFieldB"])
  CPKReciprocalChildIdFieldB: ID!
  CPKParentIdFieldA: ID
  CPKParentIdFieldB: ID
  cpkParent: CPKParent @belongsTo(references: ["CPKParentIdFieldA","CPKParentIdFieldB"])
  value: String
}

type CPKHasManyChild @model @auth(rules: [{allow: public}])
{
  value: String
  CPKHasManyChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKHasManyChildIdFieldB"])
  CPKHasManyChildIdFieldB: ID!
  CPKParentIdFieldA: ID
  CPKParentIdFieldB: ID
  cpkParent: CPKParent @belongsTo(references: ["CPKParentIdFieldA","CPKParentIdFieldB"])
}

type CPKReciprocalHasManyChild @model @auth(rules: [{allow: public}])
{
  CPKReciprocalHasManyChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKReciprocalHasManyChildIdFieldB"])
  CPKReciprocalHasManyChildIdFieldB: ID!
  value: String
  CPKParentIdFieldA: ID!
  CPKParentIdFieldB: ID!
  parent: CPKParent @belongsTo(references: ["CPKParentIdFieldA","CPKParentIdFieldB"])
}"
`;
