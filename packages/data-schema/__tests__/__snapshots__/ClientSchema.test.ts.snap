// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`RDS Schema with sql statement references schema lambda access 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type widget @model @auth(rules: [{allow: public}])
{
  title: String!
  someOwnerField: String
}

type Query {
  callSql: widget @sql(reference: "testReferenceName") @auth(rules: [{allow: public}])
}",
  "sqlStatementFolderPath": "/full/path/to/sql/statement/directory/",
}
`;

exports[`custom operations custom mutation 1`] = `
"type LikePostResult 
{
  likes: Int!
}

type Mutation {
  likePost(postId: String!): LikePostResult @function(name: "likePost") @auth(rules: [{allow: public}])
}"
`;

exports[`custom operations custom query 1`] = `
"type EchoResult 
{
  resultContent: String
}

type Query {
  echo(inputContent: String!): EchoResult @function(name: "echoFunction") @auth(rules: [{allow: public}])
}"
`;

exports[`custom operations for a.combine schema a ddb and sql schemas combine without issues 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  field: String
}
type B @model @auth(rules: [{allow: public}])
{
  field: String
}"
`;

exports[`custom operations for a.combine schema combining two schemas with custom mutation results in customTypes and customOperations that intersect the separate schemas 1`] = `
"type LikePostResult 
{
  likes: Int!
}

type A @model @auth(rules: [{allow: public}])
{
  fieldA: String
}

type Mutation {
  likePost(postId: String!): LikePostResult @function(name: "likePost") @auth(rules: [{allow: public}])
}
type DislikePostResult 
{
  likes: Int!
}

type B @model @auth(rules: [{allow: public}])
{
  fieldB: String
}

type Mutation {
  dislikePost(postId: String!): DislikePostResult @function(name: "dislikePost") @auth(rules: [{allow: public}])
}"
`;

exports[`custom operations for a.combine schema two schemas combine without issues 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  field: String
}
type B @model @auth(rules: [{allow: public}])
{
  field: String
}"
`;

exports[`custom operations for an rds schema can define public auth with no provider 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  field: String
}"
`;

exports[`custom operations for an rds schema custom operations custom query 1`] = `
"type EchoResult 
{
  resultContent: String
}

type Query {
  echo(inputContent: String!): EchoResult @function(name: "echoFunction") @auth(rules: [{allow: public}])
}"
`;

exports[`schema auth rules allows custom 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: custom}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules allows groupDefinedIn 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "someField"}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules allows groupsDefinedIn 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: groups, groupsField: "someField"}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules allows multiple entries 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public},
  {allow: private}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules allows multipleOwners 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules allows owner 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules allows private 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: private}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules allows public 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules allows specificGroups 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: groups, groups: ["a", "b"]}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules can define public auth with no provider 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  field: String
}"
`;

exports[`schema auth rules disallows specificGroup 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: groups, groups: ["group"]}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules do not pull out custom operations 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type Post @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  title: String
}

type Mutation {
  likePost(postId: String): Post @function(name: "myFunc") @auth(rules: [{allow: owner, ownerField: "owner"}])
}

type Query {
  getLikedPost: Post @function(name: "myFunc") @auth(rules: [{allow: owner, ownerField: "owner"}])
}

type Subscription {
  onLikePost: Post @function(name: "myFunc") @aws_subscribe(mutations: ["likePost"]) @auth(rules: [{allow: owner, ownerField: "owner"}])
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules global public auth - multiple models 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  field: String
}

type B @model @auth(rules: [{allow: public}])
{
  field: AWSJSON
}

type C @model @auth(rules: [{allow: public}])
{
  d: D @hasOne
  cDId: ID
}

type D @model @auth(rules: [{allow: public}])
{
  can: Int
  you: Boolean
  tell: Float
  i: AWSDate
  am: AWSIPAddress
  getting: AWSURL
  tired: DTired
}

enum DTired {
  ?
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules prefers model auth over global auth owner auth on model vs owner auth on schema 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "modelOwnerField"}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules prefers model auth over global auth owner auth on model vs public auth on schema 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema auth rules prefers model auth over global auth public auth on model vs owner auth on schema 1`] = `
{
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  field: String
}",
  "sqlStatementFolderPath": undefined,
}
`;

exports[`schema generation with relationships 1`] = `
"type BoringParent @model @auth(rules: [{allow: public}])
{
  childNormal: BoringChild @hasOne
  childReciprocal: BoringReciprocalChild @hasOne
  childHasManyNormal: [BoringHasManyChild] @hasMany
  childHasManyReciprocal: [ReciprocalHasManyChild] @hasMany
  boringParentChildNormalId: ID
  boringParentChildReciprocalId: ID
}

type BoringChild @model @auth(rules: [{allow: public}])
{
  value: String
}

type BoringReciprocalChild @model @auth(rules: [{allow: public}])
{
  parent: BoringParent @belongsTo
  value: String
  boringReciprocalChildParentId: ID
}

type BoringHasManyChild @model @auth(rules: [{allow: public}])
{
  value: String
  boringParentChildHasManyNormalId: ID
}

type ReciprocalHasManyChild @model @auth(rules: [{allow: public}])
{
  value: String
  parent: BoringParent @belongsTo
  boringParentChildHasManyReciprocalId: ID
}

type CPKParent @model @auth(rules: [{allow: public}])
{
  CPKParentIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKParentIdFieldB"])
  CPKParentIdFieldB: ID!
  childNormal: CPKChild @hasOne
  childReciprocal: CPKReciprocalChild @hasOne
  childHasManyNormal: [CPKHasManyChild] @hasMany
  childHasManyReciprocal: [CPKReciprocalHasManyChild] @hasMany
  cPKParentChildNormalCPKChildIdFieldA: ID
  cPKParentChildNormalCPKChildIdFieldB: ID
  cPKParentChildReciprocalCPKReciprocalChildIdFieldA: ID
  cPKParentChildReciprocalCPKReciprocalChildIdFieldB: ID
}

type CPKChild @model @auth(rules: [{allow: public}])
{
  CPKChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKChildIdFieldB"])
  CPKChildIdFieldB: ID!
  value: String
}

type CPKReciprocalChild @model @auth(rules: [{allow: public}])
{
  CPKReciprocalChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKReciprocalChildIdFieldB"])
  CPKReciprocalChildIdFieldB: ID!
  parent: CPKParent @belongsTo
  value: String
  cPKReciprocalChildParentCPKParentIdFieldA: ID
  cPKReciprocalChildParentCPKParentIdFieldB: ID
}

type CPKHasManyChild @model @auth(rules: [{allow: public}])
{
  CPKHasManyChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKHasManyChildIdFieldB"])
  CPKHasManyChildIdFieldB: ID!
  value: String
  cPKParentChildHasManyNormalCPKParentIdFieldA: ID
  cPKParentChildHasManyNormalCPKParentIdFieldB: ID
}

type CPKReciprocalHasManyChild @model @auth(rules: [{allow: public}])
{
  CPKReciprocalHasManyChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKReciprocalHasManyChildIdFieldB"])
  CPKReciprocalHasManyChildIdFieldB: ID!
  value: String
  parent: CPKParent @belongsTo
  cPKParentChildHasManyReciprocalCPKParentIdFieldA: ID
  cPKParentChildHasManyReciprocalCPKParentIdFieldB: ID
}

type ReferencedBoringParent @model @auth(rules: [{allow: public}])
{
  childNormal: ReferencedBoringChild @hasOne(references: ["bcRefId"])
  childReciprocal: ReferencedBoringReciprocalChild @hasOne(references: ["brcRefId"])
  childHasManyNormal: [ReferencedBoringHasManyChild] @hasMany(references: ["bhmRefId"])
  childHasManyReciprocal: [ReferencedReciprocalHasManyChild] @hasMany(references: ["rrhmRefId"])
  referencedBoringParentChildNormalId: ID
  referencedBoringParentChildReciprocalId: ID
}

type ReferencedBoringChild @model @auth(rules: [{allow: public}])
{
  bcRefId: String
  value: String
}

type ReferencedBoringReciprocalChild @model @auth(rules: [{allow: public}])
{
  brcRefId: String
  parent: ReferencedBoringParent @belongsTo(references: ["brcRefId"])
  value: String
  referencedBoringReciprocalChildParentId: ID
}

type ReferencedBoringHasManyChild @model @auth(rules: [{allow: public}])
{
  bhmRefId: String
  value: String
  referencedBoringParentChildHasManyNormalId: ID
}

type ReferencedReciprocalHasManyChild @model @auth(rules: [{allow: public}])
{
  rrhmRefId: String
  value: String
  parent: ReferencedBoringParent @belongsTo(references: ["rrhmRefId"])
  referencedBoringParentChildHasManyReciprocalId: ID
}

type LateReferencedBoringParent @model @auth(rules: [{allow: public}])
{
  childNormal: LateReferencedBoringChild @hasOne(references: ["bcRefId"])
  childReciprocal: LateReferencedBoringReciprocalChild @hasOne(references: ["brcRefId"])
  childHasManyNormal: [LateReferencedBoringHasManyChild] @hasMany(references: ["bhmRefId"])
  childHasManyReciprocal: [LateReferencedReciprocalHasManyChild] @hasMany(references: ["rrhmRefId"])
  lateReferencedBoringParentChildNormalId: ID
  lateReferencedBoringParentChildReciprocalId: ID
}

type LateReferencedBoringChild @model @auth(rules: [{allow: public}])
{
  bcRefId: String
  value: String
}

type LateReferencedBoringReciprocalChild @model @auth(rules: [{allow: public}])
{
  brcRefId: String
  value: String
  parent: ReferencedBoringParent @belongsTo(references: ["brcRefId"])
}

type LateReferencedBoringHasManyChild @model @auth(rules: [{allow: public}])
{
  bhmRefId: String
  value: String
  lateReferencedBoringParentChildHasManyNormalId: ID
}

type LateReferencedReciprocalHasManyChild @model @auth(rules: [{allow: public}])
{
  rrhmRefId: String
  value: String
  parent: ReferencedBoringParent @belongsTo(references: ["rrhmRefId"])
  lateReferencedBoringParentChildHasManyReciprocalId: ID
}"
`;
