// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`RDS Schema with sql statement references schema with full path sql reference 1`] = `
{
  "customSqlDataSourceStrategies": [
    {
      "entry": "/full/path/to/sql/statement/directory/testReferenceName",
      "fieldName": "callSql",
      "typeName": "Query",
    },
  ],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type widget @model @auth(rules: [{allow: public}])
{
  title: String!
  someOwnerField: String
}

type Query {
  callSql: widget @sql(reference: "/full/path/to/sql/statement/directory/testReferenceName") @auth(rules: [{allow: public}])
}",
}
`;

exports[`custom operations custom mutation 1`] = `
"type LikePostResult 
{
  likes: Int!
}

type Mutation {
  likePost: LikePostResult @function(name: "likePost") @auth(rules: [{allow: public}])
}"
`;

exports[`custom operations custom query 1`] = `
"type EchoResult 
{
  resultContent: String
}

type Query {
  echo: EchoResult @function(name: "echoFunction") @auth(rules: [{allow: public}])
}"
`;

exports[`custom operations for a.combine schema a ddb and sql schemas combine without issues 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  field: String
}
type B @model @auth(rules: [{allow: public}])
{
  field: String
}"
`;

exports[`custom operations for a.combine schema combining two schemas with custom mutation results in customTypes and customOperations that intersect the separate schemas 1`] = `
"type LikePostResult 
{
  likes: Int!
}

type A @model @auth(rules: [{allow: public}])
{
  fieldA: String
}

type Mutation {
  likePost: LikePostResult @function(name: "likePost") @auth(rules: [{allow: public}])
}
type DislikePostResult 
{
  likes: Int!
}

type B @model @auth(rules: [{allow: public}])
{
  fieldB: String
}

type Mutation {
  dislikePost: DislikePostResult @function(name: "dislikePost") @auth(rules: [{allow: public}])
}"
`;

exports[`custom operations for a.combine schema two schemas combine without issues 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  field: String
}
type B @model @auth(rules: [{allow: public}])
{
  field: String
}"
`;

exports[`custom operations for an rds schema can define public auth with no provider 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  id: String! @primaryKey
  field: String
}"
`;

exports[`custom operations for an rds schema custom operations custom query 1`] = `
"type EchoResult 
{
  resultContent: String
}

type Query {
  echo: EchoResult @function(name: "echoFunction") @auth(rules: [{allow: public}])
}"
`;

exports[`custom operations for an rds schema sql schema field-level auth 1`] = `
"type post @model @auth(rules: [{allow: public}])
{
  id: String! @primaryKey @auth(rules: [{allow: private}])
  title: String @auth(rules: [{allow: public}])
  author: String @auth(rules: [{allow: owner, ownerField: "author"}])
}"
`;

exports[`custom operations for an rds schema sql schema rename 1`] = `
"type RenamedPost @model @auth(rules: [{allow: public}])
{
  id: String! @primaryKey
  title: String
  author: String
}"
`;

exports[`custom operations for an rds schema sql schema rename multiple models 1`] = `
"type tags @model @auth(rules: [{allow: public}])
{
  id: String! @primaryKey
  title: String
  author: String
}

type RenamedPost @model @auth(rules: [{allow: public}])
{
  id: String! @primaryKey
  title: String
  author: String
}

type RenamedComment @model @auth(rules: [{allow: public}])
{
  id: String! @primaryKey
  title: String
  author: String
}"
`;

exports[`schema auth rules allows custom 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: custom}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows groupDefinedIn 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "someField"}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows groupsDefinedIn 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: groups, groupsField: "someField"}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows multiple entries 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public},
  {allow: private}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows multipleOwners 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows owner 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows private 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: private}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows public 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  field: String
}",
}
`;

exports[`schema auth rules allows specificGroups 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: groups, groups: ["a", "b"]}])
{
  field: String
}",
}
`;

exports[`schema auth rules can define public auth with no provider 1`] = `
"type A @model @auth(rules: [{allow: public}])
{
  field: String
}"
`;

exports[`schema auth rules disallows specificGroup 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: groups, groups: ["group"]}])
{
  field: String
}",
}
`;

exports[`schema auth rules do not pull out custom operations 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type Post @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  title: String
}

type Mutation {
  likePost: Post @function(name: "myFunc") @auth(rules: [{allow: owner, ownerField: "owner"}])
}

type Query {
  getLikedPost: Post @function(name: "myFunc") @auth(rules: [{allow: owner, ownerField: "owner"}])
}

type Subscription {
  onLikePost: Post @function(name: "myFunc") @aws_subscribe(mutations: ["likePost"]) @auth(rules: [{allow: owner, ownerField: "owner"}])
}",
}
`;

exports[`schema auth rules global public auth - multiple models 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  field: String
}

type B @model @auth(rules: [{allow: public}])
{
  field: AWSJSON
}

type C @model @auth(rules: [{allow: public}])
{
  d: D @hasOne
  cDId: ID
}

type D @model @auth(rules: [{allow: public}])
{
  can: Int
  you: Boolean
  tell: Float
  i: AWSDate
  am: AWSIPAddress
  getting: AWSURL
  tired: DTired
}

enum DTired {
  ?
}",
}
`;

exports[`schema auth rules prefers model auth over global auth owner auth on model vs owner auth on schema 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "modelOwnerField"}])
{
  field: String
}",
}
`;

exports[`schema auth rules prefers model auth over global auth owner auth on model vs public auth on schema 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: owner, ownerField: "owner"}])
{
  field: String
}",
}
`;

exports[`schema auth rules prefers model auth over global auth public auth on model vs owner auth on schema 1`] = `
{
  "customSqlDataSourceStrategies": [],
  "functionSchemaAccess": [],
  "functionSlots": [],
  "jsFunctions": [],
  "lambdaFunctions": {},
  "schema": "type A @model @auth(rules: [{allow: public}])
{
  field: String
}",
}
`;

exports[`schema generation with relationships 1`] = `
"type BoringParent @model @auth(rules: [{allow: public}])
{
  childNormal: BoringChild @hasOne
  childReciprocal: BoringReciprocalChild @hasOne
  childHasManyNormal: [BoringHasManyChild] @hasMany
  childHasManyReciprocal: [ReciprocalHasManyChild] @hasMany
  boringParentChildNormalId: ID
  boringParentChildReciprocalId: ID
}

type BoringChild @model @auth(rules: [{allow: public}])
{
  value: String
}

type BoringReciprocalChild @model @auth(rules: [{allow: public}])
{
  parent: BoringParent @belongsTo
  value: String
  boringReciprocalChildParentId: ID
}

type BoringHasManyChild @model @auth(rules: [{allow: public}])
{
  value: String
  boringParentChildHasManyNormalId: ID
}

type ReciprocalHasManyChild @model @auth(rules: [{allow: public}])
{
  value: String
  parent: BoringParent @belongsTo
  boringParentChildHasManyReciprocalId: ID
}

type CPKParent @model @auth(rules: [{allow: public}])
{
  CPKParentIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKParentIdFieldB"])
  CPKParentIdFieldB: ID!
  childNormal: CPKChild @hasOne
  childReciprocal: CPKReciprocalChild @hasOne
  childHasManyNormal: [CPKHasManyChild] @hasMany
  childHasManyReciprocal: [CPKReciprocalHasManyChild] @hasMany
  cPKParentChildNormalCPKChildIdFieldA: ID
  cPKParentChildNormalCPKChildIdFieldB: ID
  cPKParentChildReciprocalCPKReciprocalChildIdFieldA: ID
  cPKParentChildReciprocalCPKReciprocalChildIdFieldB: ID
}

type CPKChild @model @auth(rules: [{allow: public}])
{
  CPKChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKChildIdFieldB"])
  CPKChildIdFieldB: ID!
  value: String
}

type CPKReciprocalChild @model @auth(rules: [{allow: public}])
{
  CPKReciprocalChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKReciprocalChildIdFieldB"])
  CPKReciprocalChildIdFieldB: ID!
  parent: CPKParent @belongsTo
  value: String
  cPKReciprocalChildParentCPKParentIdFieldA: ID
  cPKReciprocalChildParentCPKParentIdFieldB: ID
}

type CPKHasManyChild @model @auth(rules: [{allow: public}])
{
  CPKHasManyChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKHasManyChildIdFieldB"])
  CPKHasManyChildIdFieldB: ID!
  value: String
  cPKParentChildHasManyNormalCPKParentIdFieldA: ID
  cPKParentChildHasManyNormalCPKParentIdFieldB: ID
}

type CPKReciprocalHasManyChild @model @auth(rules: [{allow: public}])
{
  CPKReciprocalHasManyChildIdFieldA: ID! @primaryKey(sortKeyFields: ["CPKReciprocalHasManyChildIdFieldB"])
  CPKReciprocalHasManyChildIdFieldB: ID!
  value: String
  parent: CPKParent @belongsTo
  cPKParentChildHasManyReciprocalCPKParentIdFieldA: ID
  cPKParentChildHasManyReciprocalCPKParentIdFieldB: ID
}"
`;
