<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@aws-amplify/data-schema](./data-schema.md)

## data-schema package

## Enumerations

<table><thead><tr><th>

Enumeration


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[ModelFieldDataType](./data-schema.modelfielddatatype.md)


</td><td>


</td></tr>
<tr><td>

[ModelFieldType](./data-schema.modelfieldtype.md)


</td><td>


</td></tr>
<tr><td>

[ModelRelationshipTypes](./data-schema.modelrelationshiptypes.md)


</td><td>


</td></tr>
</tbody></table>

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[accessData(authorization)](./data-schema.accessdata.md)


</td><td>


</td></tr>
<tr><td>

[accessSchemaData(authorization)](./data-schema.accessschemadata.md)


</td><td>


</td></tr>
<tr><td>

[belongsTo(relatedModel, references)](./data-schema.belongsto.md)


</td><td>

Use `belongsTo()` to create a field to query the related `hasOne()` or `hasMany()` relationship. The belongsTo() method requires that a hasOne() or hasMany() relationship already exists from parent to the related model.


</td></tr>
<tr><td>

[boolean()](./data-schema.boolean.md)


</td><td>

A boolean scalar type that can be either true or false.


</td></tr>
<tr><td>

[brand(brand)](./data-schema.brand.md)


</td><td>

Create an object of a specific type Brand string branded type.


</td></tr>
<tr><td>

[combine(schemas)](./data-schema.combine.md)


</td><td>

The interface for merging up to 50 schemas into a single API.


</td></tr>
<tr><td>

[configure(config)](./data-schema.configure.md)


</td><td>

Configure wraps schema definition with non-default config to allow usecases other than the default DynamoDB use-case.


</td></tr>
<tr><td>

[custom(customHandler)](./data-schema.custom.md)


</td><td>

Use a custom JavaScript resolver to handle a query, mutation, or subscription.


</td></tr>
<tr><td>

[customType(fields)](./data-schema.customtype.md)


</td><td>

Define a custom type. This type represents an inline, typed JSON object.


</td></tr>
<tr><td>

[date()](./data-schema.date.md)


</td><td>

A date scalar type that is represented server-side as an extended ISO 8601 date string in the format `YYYY-MM-DD`<!-- -->.


</td></tr>
<tr><td>

[datetime()](./data-schema.datetime.md)


</td><td>

A date time scalar type that is represented server-side as an extended ISO 8601 date and time string in the format `YYYY-MM-DDThh:mm:ss.sssZ`<!-- -->.


</td></tr>
<tr><td>

[email()](./data-schema.email.md)


</td><td>

An email scalar type that is represented server-side in the format `local-part@domain-part` as defined by RFC 822.


</td></tr>
<tr><td>

[enumType(values)](./data-schema.enumtype.md)


</td><td>

this type param pattern allows us to infer literal type values from the array without using the `as const` suffix


</td></tr>
<tr><td>

[fcn(fn)](./data-schema.fcn.md)


</td><td>

Use a function created via `defineFunction` to handle the custom query/mutation/subscription. In your function handler, you can use the `Schema["YOUR_QUERY_OR_MUTATION_NAME"]["functionHandler"]` utility type to type the handler function.


</td></tr>
<tr><td>

[float()](./data-schema.float.md)


</td><td>

A float scalar type following represented server-side as an IEEE 754 floating point value.


</td></tr>
<tr><td>

[getBrand(branded)](./data-schema.getbrand.md)


</td><td>


</td></tr>
<tr><td>

[getHandlerData(handler)](./data-schema.gethandlerdata.md)


</td><td>


</td></tr>
<tr><td>

[hasMany(relatedModel, references)](./data-schema.hasmany.md)


</td><td>

Create a one-directional one-to-many relationship between two models using the `hasMany("MODEL_NAME", "REFERENCE_FIELD(s)")` method.


</td></tr>
<tr><td>

[hasOne(relatedModel, references)](./data-schema.hasone.md)


</td><td>

Create one-to-one relationship between two models using the `hasOne("MODEL_NAME", "REFERENCE_FIELD(s)")` method. A hasOne relationship always uses a reference to the related model's identifier. Typically this is the `id` field unless overwritten with the `identifier()` method.


</td></tr>
<tr><td>

[id()](./data-schema.id.md)


</td><td>

A unique identifier scalar type. This scalar is serialized like a String but isn't meant to be human-readable. If not specified on create operations, a ULID will be auto-generated service-side.


</td></tr>
<tr><td>

[identityClaim(this, property)](./data-schema.identityclaim.md)


</td><td>

Specifies a property of the identity JWT to use in place of `sub::username` as the value to match against the owner field for authorization.


</td></tr>
<tr><td>

[inlineSql(sql)](./data-schema.inlinesql.md)


</td><td>


</td></tr>
<tr><td>

[integer()](./data-schema.integer.md)


</td><td>

An integer scalar type with a supported value range between -(2^31) and 2^31-1.


</td></tr>
<tr><td>

[ipAddress()](./data-schema.ipaddress.md)


</td><td>

A valid IPv4 or IPv6 address scalar type. IPv4 addresses are expected in quad-dotted notation (123.12.34.56). IPv6 addresses are expected in non-bracketed, colon-separated format (1a2b:3c4b:ðŸ”¢4567). You can include an optional CIDR suffix (123.45.67.89/16) to indicate subnet mask.


</td></tr>
<tr><td>

[isCustomPathData(obj)](./data-schema.iscustompathdata.md)


</td><td>


</td></tr>
<tr><td>

[isModelSchema(schema)](./data-schema.ismodelschema.md)


</td><td>

Model Schema type guard


</td></tr>
<tr><td>

[isSchemaModelType(modelType)](./data-schema.isschemamodeltype.md)


</td><td>

Model Type type guard


</td></tr>
<tr><td>

[json()](./data-schema.json.md)


</td><td>

A JSON scalar type that is automatically parsed and loaded server-side as maps, lists, or scalar values rather than as the literal input strings.


</td></tr>
<tr><td>

[model(fields)](./data-schema.model.md)


</td><td>

A data model that creates a matching Amazon DynamoDB table and provides create, read (list and get), update, delete, and subscription APIs.


</td></tr>
<tr><td>

[modelIndex(partitionKeyFieldName)](./data-schema.modelindex.md)


</td><td>


</td></tr>
<tr><td>

[mutation()](./data-schema.mutation.md)


</td><td>

Use a custom mutation to define an API request that will modify backend data or trigger a subscription event.


</td></tr>
<tr><td>

[phone()](./data-schema.phone.md)


</td><td>

A phone number scalar type thas is stored as a string server-side. Phone numbers can contain either spaces or hyphens to separate digit groups. Phone numbers without a country code are assumed to be US/North American numbers adhering to the North American Numbering Plan.


</td></tr>
<tr><td>

[query()](./data-schema.query.md)


</td><td>

Use a custom query to define an API request that will retrieve backend data.


</td></tr>
<tr><td>

[ref(link)](./data-schema.ref.md)


</td><td>


</td></tr>
<tr><td>

[resourceTo(this, operations)](./data-schema.resourceto.md)


</td><td>


</td></tr>
<tr><td>

[schema(types)](./data-schema.schema.md)


</td><td>

The API and data model definition for Amplify Data. Pass in `{ <NAME>: a.model(...) }` to create a database table and exposes CRUDL operations via an API.


</td></tr>
<tr><td>

[sqlReference(sqlFilePath)](./data-schema.sqlreference.md)


</td><td>


</td></tr>
<tr><td>

[string()](./data-schema.string.md)


</td><td>

A string scalar type that is represented server-side as a UTF-8 character sequence.


</td></tr>
<tr><td>

[subscription()](./data-schema.subscription.md)


</td><td>

Define a custom subscription to receive an event when a mutation is triggered


</td></tr>
<tr><td>

[time()](./data-schema.time.md)


</td><td>

A time scalar type that is represented server-side as an extended ISO 8601 time string in the format `hh:mm:ss.sss`<!-- -->.


</td></tr>
<tr><td>

[timestamp()](./data-schema.timestamp.md)


</td><td>

A timestamp scalar type that is represented by an integer value of the number of seconds before or after `1970-01-01-T00:00Z`<!-- -->.


</td></tr>
<tr><td>

[to(this, operations)](./data-schema.to.md)


</td><td>


</td></tr>
<tr><td>

[url()](./data-schema.url.md)


</td><td>

A URL scalar type as defined by RFC 1738. For example, https://www.amazon.com/dp/B000NZW3KC/ or mailto:example<!-- -->@<!-- -->example.com. URLs must contain a schema (http, mailto) and can't contain two forward slashes (//) in the path part.


</td></tr>
<tr><td>

[withClaimIn(this, property)](./data-schema.withclaimin.md)


</td><td>


</td></tr>
</tbody></table>

## Interfaces

<table><thead><tr><th>

Interface


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[ClientCustomOperation](./data-schema.clientcustomoperation.md)


</td><td>

Derives the signature and types for a lambda handler for a particular custom Query or Mutation from a Schema.


</td></tr>
<tr><td>

[ClientCustomType](./data-schema.clientcustomtype.md)


</td><td>


</td></tr>
<tr><td>

[ClientEnum](./data-schema.clientenum.md)


</td><td>


</td></tr>
<tr><td>

[ClientModel](./data-schema.clientmodel.md)


</td><td>


</td></tr>
<tr><td>

[ClientSchemaPropertyType](./data-schema.clientschemapropertytype.md)


</td><td>


</td></tr>
<tr><td>

[DerivedApiDefinition](./data-schema.derivedapidefinition.md)


</td><td>


</td></tr>
<tr><td>

[EnumType](./data-schema.enumtype.md)


</td><td>


</td></tr>
<tr><td>

[GraphQLFormattedError](./data-schema.graphqlformattederror.md)


</td><td>

See: https://spec.graphql.org/draft/\#sec-Errors


</td></tr>
<tr><td>

[InternalField](./data-schema.internalfield.md)


</td><td>

Internal representation of Model Field that exposes the `data` property. Used at buildtime.


</td></tr>
<tr><td>

[PrimaryIndexIrBuilderShape](./data-schema.primaryindexirbuildershape.md)


</td><td>


</td></tr>
<tr><td>

[SchemaMetadata](./data-schema.schemametadata.md)


</td><td>


</td></tr>
<tr><td>

[SecondaryIndexIrBuilderShape](./data-schema.secondaryindexirbuildershape.md)


</td><td>


</td></tr>
<tr><td>

[SourceLocation](./data-schema.sourcelocation.md)


</td><td>

Represents a location in a Source.


</td></tr>
</tbody></table>

## Namespaces

<table><thead><tr><th>

Namespace


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[a](./data-schema.a.md)


</td><td>


</td></tr>
</tbody></table>

## Variables

<table><thead><tr><th>

Variable


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[\_\_modelFieldAuth](./data-schema.__modelfieldauth.md)


</td><td>

Used to "attach" auth types to ModelField without exposing them on the builder.


</td></tr>
<tr><td>

[\_\_modelMeta\_\_](./data-schema.__modelmeta__.md)


</td><td>


</td></tr>
<tr><td>

[\_\_modelRelationalFieldAuth](./data-schema.__modelrelationalfieldauth.md)


</td><td>

Used to "attach" auth types to ModelField without exposing them on the builder.


</td></tr>
<tr><td>

[allow](./data-schema.allow.md)


</td><td>

Defines an authorization rule for your data models and fields. First choose an authorization strategy (`public`<!-- -->, `private`<!-- -->, `owner`<!-- -->, `group`<!-- -->, or `custom`<!-- -->), then choose an auth provider (`apiKey`<!-- -->, `identitypool`<!-- -->, `userPools`<!-- -->, `oidc`<!-- -->, or `function`<!-- -->) and optionally use `.to(...)` to specify the operations that can be performed against your data models and fields.


</td></tr>
<tr><td>

[allowForCustomOperations](./data-schema.allowforcustomoperations.md)


</td><td>

This is a copy of the [allow](./data-schema.allow.md) defined above, with modifications for custom operations.

Removed builder methods:

\* `owner` \* `ownerDefinedIn` \* `ownersDefinedIn` \* `groupDefinedIn` \* `groupsDefinedIn` \* `resource` \* `.to()` builder method from each available rule builder


</td></tr>
<tr><td>

[COMBINED\_SCHEMA\_LIMIT](./data-schema.combined_schema_limit.md)


</td><td>


</td></tr>
<tr><td>

[combinedSchemaBrand](./data-schema.combinedschemabrand.md)


</td><td>


</td></tr>
<tr><td>

[combinedSchemaBrandName](./data-schema.combinedschemabrandname.md)


</td><td>


</td></tr>
<tr><td>

[customHandlerBrand](./data-schema.customhandlerbrand.md)


</td><td>


</td></tr>
<tr><td>

[CustomOperationNames](./data-schema.customoperationnames.md)


</td><td>


</td></tr>
<tr><td>

[CustomProviders](./data-schema.customproviders.md)


</td><td>

The subset of auth providers that can facilitate `custom` auth.


</td></tr>
<tr><td>

[ddbSchemaBrandName](./data-schema.ddbschemabrandname.md)


</td><td>


</td></tr>
<tr><td>

[functionHandlerBrand](./data-schema.functionhandlerbrand.md)


</td><td>


</td></tr>
<tr><td>

[GroupProviders](./data-schema.groupproviders.md)


</td><td>

The subset of auth providers that can facilitate `group` auth.


</td></tr>
<tr><td>

[handler](./data-schema.handler.md)


</td><td>


</td></tr>
<tr><td>

[inlineSqlBrand](./data-schema.inlinesqlbrand.md)


</td><td>


</td></tr>
<tr><td>

[modelFieldBrandName](./data-schema.modelfieldbrandname.md)


</td><td>


</td></tr>
<tr><td>

[modelIndexBrandName](./data-schema.modelindexbrandname.md)


</td><td>


</td></tr>
<tr><td>

[modelRelationalFieldBrandName](./data-schema.modelrelationalfieldbrandname.md)


</td><td>


</td></tr>
<tr><td>

[modelTypeBrandName](./data-schema.modeltypebrandname.md)


</td><td>


</td></tr>
<tr><td>

[mutationBrand](./data-schema.mutationbrand.md)


</td><td>


</td></tr>
<tr><td>

[Operations](./data-schema.operations.md)


</td><td>

The operations that can be performed against an API.


</td></tr>
<tr><td>

[OwnerProviders](./data-schema.ownerproviders.md)


</td><td>

The subset of auth providers that can facilitate `owner` auth.


</td></tr>
<tr><td>

[PrivateProviders](./data-schema.privateproviders.md)


</td><td>

The subset of auth providers that can facilitate `private` auth.


</td></tr>
<tr><td>

[Providers](./data-schema.providers.md)


</td><td>

All possible providers.

This list should not be used if you need to restrict available providers according to an auth strategcy. E.g., `public` auth can only be facilitated by `apiKey` and `identityPool` providers.


</td></tr>
<tr><td>

[PublicProviders](./data-schema.publicproviders.md)


</td><td>

The subset of auth providers that can facilitate `public` auth.


</td></tr>
<tr><td>

[queryBrand](./data-schema.querybrand.md)


</td><td>


</td></tr>
<tr><td>

[rdsSchemaBrand](./data-schema.rdsschemabrand.md)


</td><td>


</td></tr>
<tr><td>

[rdsSchemaBrandName](./data-schema.rdsschemabrandname.md)


</td><td>


</td></tr>
<tr><td>

[refTypeBrandName](./data-schema.reftypebrandname.md)


</td><td>


</td></tr>
<tr><td>

[ResourceOperations](./data-schema.resourceoperations.md)


</td><td>

The operations that can be performed against an API by a Lambda function.


</td></tr>
<tr><td>

[sqlReferenceBrand](./data-schema.sqlreferencebrand.md)


</td><td>


</td></tr>
<tr><td>

[Strategies](./data-schema.strategies.md)


</td><td>


</td></tr>
<tr><td>

[subscriptionBrand](./data-schema.subscriptionbrand.md)


</td><td>


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[AddRelationshipFieldsToModelTypeFields](./data-schema.addrelationshipfieldstomodeltypefields.md)


</td><td>


</td></tr>
<tr><td>

[AddToSchemaContent](./data-schema.addtoschemacontent.md)


</td><td>


</td></tr>
<tr><td>

[AddToSchemaContents](./data-schema.addtoschemacontents.md)


</td><td>


</td></tr>
<tr><td>

[AllHandlers](./data-schema.allhandlers.md)


</td><td>


</td></tr>
<tr><td>

[AllowModifier](./data-schema.allowmodifier.md)


</td><td>


</td></tr>
<tr><td>

[AllowModifierForCustomOperation](./data-schema.allowmodifierforcustomoperation.md)


</td><td>


</td></tr>
<tr><td>

[ApplyRequiredness](./data-schema.applyrequiredness.md)


</td><td>


</td></tr>
<tr><td>

[ArrayField](./data-schema.arrayfield.md)


</td><td>


</td></tr>
<tr><td>

[ArrayShift](./data-schema.arrayshift.md)


</td><td>


</td></tr>
<tr><td>

[AuthFields](./data-schema.authfields.md)


</td><td>


</td></tr>
<tr><td>

[AuthFieldsMetadata](./data-schema.authfieldsmetadata.md)


</td><td>


</td></tr>
<tr><td>

[AuthMode](./data-schema.authmode.md)


</td><td>


</td></tr>
<tr><td>

[Authorization](./data-schema.authorization.md)


</td><td>


</td></tr>
<tr><td>

[BaseModelField](./data-schema.basemodelfield.md)


</td><td>


</td></tr>
<tr><td>

[BaseModelType](./data-schema.basemodeltype.md)


</td><td>


</td></tr>
<tr><td>

[BaseSchema](./data-schema.baseschema.md)


</td><td>


</td></tr>
<tr><td>

[BooleanFilters](./data-schema.booleanfilters.md)


</td><td>


</td></tr>
<tr><td>

[Brand](./data-schema.brand.md)


</td><td>


</td></tr>
<tr><td>

[ClientFields](./data-schema.clientfields.md)


</td><td>


</td></tr>
<tr><td>

[ClientSchema](./data-schema.clientschema.md)


</td><td>


</td></tr>
<tr><td>

[ClientSchemaByEntityType](./data-schema.clientschemabyentitytype.md)


</td><td>


</td></tr>
<tr><td>

[ClientSchemaByEntityTypeBaseShape](./data-schema.clientschemabyentitytypebaseshape.md)


</td><td>


</td></tr>
<tr><td>

[ClientSchemaProperty](./data-schema.clientschemaproperty.md)


</td><td>


</td></tr>
<tr><td>

[CombinedClientSchemas](./data-schema.combinedclientschemas.md)


</td><td>


</td></tr>
<tr><td>

[CombinedModelSchema](./data-schema.combinedmodelschema.md)


</td><td>


</td></tr>
<tr><td>

[CombinedSchemaBrand](./data-schema.combinedschemabrand.md)


</td><td>


</td></tr>
<tr><td>

[CombinedSchemaIndexesUnion](./data-schema.combinedschemaindexesunion.md)


</td><td>


</td></tr>
<tr><td>

[CompositeSkFieldName](./data-schema.compositeskfieldname.md)


</td><td>


</td></tr>
<tr><td>

[ContextType](./data-schema.contexttype.md)


</td><td>


</td></tr>
<tr><td>

[CreateModelInput](./data-schema.createmodelinput.md)


</td><td>

All identifiers and fields used to create a model


</td></tr>
<tr><td>

[CustomArguments](./data-schema.customarguments.md)


</td><td>


</td></tr>
<tr><td>

[CustomData](./data-schema.customdata.md)


</td><td>


</td></tr>
<tr><td>

[CustomHandler](./data-schema.customhandler.md)


</td><td>


</td></tr>
<tr><td>

[CustomHandlerData](./data-schema.customhandlerdata.md)


</td><td>


</td></tr>
<tr><td>

[CustomHandlerInput](./data-schema.customhandlerinput.md)


</td><td>


</td></tr>
<tr><td>

[CustomHeaders](./data-schema.customheaders.md)


</td><td>

Custom headers that can be passed either to the client or to individual model operations, either as a static object or a function that returns a promise.


</td></tr>
<tr><td>

[CustomMutations](./data-schema.custommutations.md)


</td><td>


</td></tr>
<tr><td>

[CustomOpArguments](./data-schema.customoparguments.md)


</td><td>

Digs out custom operation arguments, mapped to the intended graphql types.


</td></tr>
<tr><td>

[CustomOperation](./data-schema.customoperation.md)


</td><td>


</td></tr>
<tr><td>

[CustomOperationBrand](./data-schema.customoperationbrand.md)


</td><td>


</td></tr>
<tr><td>

[CustomOperationFnParams](./data-schema.customoperationfnparams.md)


</td><td>

Generates Custom Operations function params based on whether .arguments() were specified in the schema builder


</td></tr>
<tr><td>

[CustomOperationMethodOptions](./data-schema.customoperationmethodoptions.md)


</td><td>


</td></tr>
<tr><td>

[CustomOperationName](./data-schema.customoperationname.md)


</td><td>


</td></tr>
<tr><td>

[CustomOperationParamShape](./data-schema.customoperationparamshape.md)


</td><td>


</td></tr>
<tr><td>

[CustomOperations](./data-schema.customoperations.md)


</td><td>


</td></tr>
<tr><td>

[CustomOperationSubType](./data-schema.customoperationsubtype.md)


</td><td>


</td></tr>
<tr><td>

[CustomOpReturnType](./data-schema.customopreturntype.md)


</td><td>

Computes the return type from the `returnType` of a custom operation shape.

This entails dereferencing refs and inferring graphql types from field-type defs.


</td></tr>
<tr><td>

[CustomPathData](./data-schema.custompathdata.md)


</td><td>


</td></tr>
<tr><td>

[CustomProvider](./data-schema.customprovider.md)


</td><td>


</td></tr>
<tr><td>

[CustomQueries](./data-schema.customqueries.md)


</td><td>


</td></tr>
<tr><td>

[CustomReturnType](./data-schema.customreturntype.md)


</td><td>


</td></tr>
<tr><td>

[CustomSqlDataSourceStrategy](./data-schema.customsqldatasourcestrategy.md)


</td><td>


</td></tr>
<tr><td>

[CustomSubscriptions](./data-schema.customsubscriptions.md)


</td><td>


</td></tr>
<tr><td>

[CustomType](./data-schema.customtype.md)


</td><td>


</td></tr>
<tr><td>

[CustomTypeAllowedModifiers](./data-schema.customtypeallowedmodifiers.md)


</td><td>

Custom Types

can be defined in-line to strongly type object types


</td></tr>
<tr><td>

[CustomTypeData](./data-schema.customtypedata.md)


</td><td>


</td></tr>
<tr><td>

[CustomTypeFields](./data-schema.customtypefields.md)


</td><td>


</td></tr>
<tr><td>

[CustomTypeParamShape](./data-schema.customtypeparamshape.md)


</td><td>


</td></tr>
<tr><td>

[DataSourceConfiguration](./data-schema.datasourceconfiguration.md)


</td><td>


</td></tr>
<tr><td>

[DatasourceEngine](./data-schema.datasourceengine.md)


</td><td>


</td></tr>
<tr><td>

[DDBSchemaBrand](./data-schema.ddbschemabrand.md)


</td><td>


</td></tr>
<tr><td>

[Debug](./data-schema.debug.md)


</td><td>


</td></tr>
<tr><td>

[DeepReadOnlyObject](./data-schema.deepreadonlyobject.md)


</td><td>


</td></tr>
<tr><td>

[deferredRefResolvingPrefix](./data-schema.deferredrefresolvingprefix.md)


</td><td>


</td></tr>
<tr><td>

[DefineFunction](./data-schema.definefunction.md)


</td><td>


</td></tr>
<tr><td>

[DerivedCombinedSchema](./data-schema.derivedcombinedschema.md)


</td><td>


</td></tr>
<tr><td>

[DerivedModelSchema](./data-schema.derivedmodelschema.md)


</td><td>


</td></tr>
<tr><td>

[EntriesToRecordTuple](./data-schema.entriestorecordtuple.md)


</td><td>

Turns this:

```ts
type E = [
 ['keyA', 'valueA'],
 ['keyB', 'valueB'],
 ['keyC', 'valueC'],
]
```
Into this:

```ts
type R = [
 Record<"keyA", "valueA">,
 Record<"keyB", "valueB">,
 Record<"keyC", "valueC">,
]
```


</td></tr>
<tr><td>

[EnumTypeParamShape](./data-schema.enumtypeparamshape.md)


</td><td>


</td></tr>
<tr><td>

[EnumTypes](./data-schema.enumtypes.md)


</td><td>

The utility type that is used to infer the type (interface) of the generated `client.enums` property.


</td></tr>
<tr><td>

[Equal](./data-schema.equal.md)


</td><td>


</td></tr>
<tr><td>

[ExcludeEmpty](./data-schema.excludeempty.md)


</td><td>


</td></tr>
<tr><td>

[Expect](./data-schema.expect.md)


</td><td>


</td></tr>
<tr><td>

[ExpectFalse](./data-schema.expectfalse.md)


</td><td>


</td></tr>
<tr><td>

[ExpectTrue](./data-schema.expecttrue.md)


</td><td>


</td></tr>
<tr><td>

[ExtractModelMeta](./data-schema.extractmodelmeta.md)


</td><td>


</td></tr>
<tr><td>

[ExtractNestedTypes](./data-schema.extractnestedtypes.md)


</td><td>


</td></tr>
<tr><td>

[ExtractNonNullableFieldsToRequiredFields](./data-schema.extractnonnullablefieldstorequiredfields.md)


</td><td>


</td></tr>
<tr><td>

[ExtractNullableFieldsToOptionalFields](./data-schema.extractnullablefieldstooptionalfields.md)


</td><td>


</td></tr>
<tr><td>

[ExtractSecondaryIndexIRFields](./data-schema.extractsecondaryindexirfields.md)


</td><td>

Extract fields that are eligible to be PK or SK fields with their resolved type.

Eligible fields include: 1. ModelField that contains string or number 2. inline EnumType 3. RefType that refers to a top level defined EnumType (this is enforced by validation that happens in the Schema Processor)

NOTE: at this point, there is no way to resolve the type from a RefType as we don't have access to the NonModelType at this location. So we generate am indicator string, and resolve its corresponding type later in packages/data-schema/src/runtime/client/index.ts


</td></tr>
<tr><td>

[FieldData](./data-schema.fielddata.md)


</td><td>


</td></tr>
<tr><td>

[FieldTypesOfCustomType](./data-schema.fieldtypesofcustomtype.md)


</td><td>

Resolves field types for a CustomType.

This utility type is needed in addition to the `FieldTypes` utility type as without checking `ModelRelationalField` can improve \~5% on resolving performance.

Non-model types are replaced with Refs. Refs remain and are resolved in ResolveFieldProperties.ts


</td></tr>
<tr><td>

[FunctionHandler](./data-schema.functionhandler.md)


</td><td>


</td></tr>
<tr><td>

[FunctionHandlerData](./data-schema.functionhandlerdata.md)


</td><td>


</td></tr>
<tr><td>

[FunctionSchemaAccess](./data-schema.functionschemaaccess.md)


</td><td>


</td></tr>
<tr><td>

[GenericModelSchema](./data-schema.genericmodelschema.md)


</td><td>


</td></tr>
<tr><td>

[GetInternalClientSchema](./data-schema.getinternalclientschema.md)


</td><td>


</td></tr>
<tr><td>

[GroupProvider](./data-schema.groupprovider.md)


</td><td>


</td></tr>
<tr><td>

[HandlerInputType](./data-schema.handlerinputtype.md)


</td><td>


</td></tr>
<tr><td>

[HandlerType](./data-schema.handlertype.md)


</td><td>


</td></tr>
<tr><td>

[HasKey](./data-schema.haskey.md)


</td><td>


</td></tr>
<tr><td>

[If](./data-schema.if.md)


</td><td>


</td></tr>
<tr><td>

[IfEquals](./data-schema.ifequals.md)


</td><td>


</td></tr>
<tr><td>

[ImplicitIdentifier](./data-schema.implicitidentifier.md)


</td><td>

Separate util for \*injecting\* the default implicit identifier for performance reasons. The full ModelIdentifer util needs to extract types from the fields matching the explicitly defined field types. Contrast that to \*\*injecting\*\* PK fields into the model, which is only done specifically when the default of `readonly id: string` is being injected IF AND ONLY IF another `id` field is not already present on the model.


</td></tr>
<tr><td>

[ImpliedAuthField](./data-schema.impliedauthfield.md)


</td><td>

Turns the type from a list of `Authorization` rules like this:

```typescript
[
 allow.public(),
 allow.ownerDefinedIn('otherfield'),
 allow.ownersDefinedIn('editors')
]
```
Into a union of the possible `fieldname: type` auth objects like this:

```typescript
{
 owner?: string | undefined;
} | {
 otherfield?: string | undefined;
} | {
 editors?: string[] | undefined;
}
```


</td></tr>
<tr><td>

[ImpliedAuthFields](./data-schema.impliedauthfields.md)


</td><td>

Turns the type from a list of `Authorization` rules like this:

```typescript
[
 allow.public(),
 allow.ownerDefinedIn('otherfield'),
 allow.ownersDefinedIn('editors')
]
```
Into an object type that includes all auth fields like this:

```typescript
{
 owner?: string | undefined;
 otherfield?: string | undefined;
 editors?: string[] | undefined;
}
```


</td></tr>
<tr><td>

[ImpliedAuthFieldsFromFields](./data-schema.impliedauthfieldsfromfields.md)


</td><td>


</td></tr>
<tr><td>

[IndexLimitUnion](./data-schema.indexlimitunion.md)


</td><td>

Create a type literal of numbers as index strings The resulting literal will include 0 up to (N - 1)


</td></tr>
<tr><td>

[IndexQueryInput](./data-schema.indexqueryinput.md)


</td><td>

Accepts a PrimaryIndexIr or SecondaryIndexIr and returns resolved parameters

TODO: Get rid of the `deferredRefResolvingPrefix` reference hack. Instead, just dereference refs as usual?


</td></tr>
<tr><td>

[IndexQueryMethodsFromIR](./data-schema.indexquerymethodsfromir.md)


</td><td>


</td></tr>
<tr><td>

[IndexQueryMethodSignature](./data-schema.indexquerymethodsignature.md)


</td><td>


</td></tr>
<tr><td>

[InlineSqlHandler](./data-schema.inlinesqlhandler.md)


</td><td>


</td></tr>
<tr><td>

[InternalClientSchema](./data-schema.internalclientschema.md)


</td><td>


</td></tr>
<tr><td>

[InternalCombinedSchema](./data-schema.internalcombinedschema.md)


</td><td>

Types for unwrapping and combining generic type args into client-consumable types for multiple schemas


</td></tr>
<tr><td>

[InternalCustom](./data-schema.internalcustom.md)


</td><td>

Internal representation of Custom Type that exposes the `data` property. Used at buildtime.


</td></tr>
<tr><td>

[InternalCustomArguments](./data-schema.internalcustomarguments.md)


</td><td>


</td></tr>
<tr><td>

[InternalCustomData](./data-schema.internalcustomdata.md)


</td><td>


</td></tr>
<tr><td>

[InternalCustomReturnType](./data-schema.internalcustomreturntype.md)


</td><td>


</td></tr>
<tr><td>

[InternalCustomType](./data-schema.internalcustomtype.md)


</td><td>

Internal representation of CustomType that exposes the `data` property. Used at buildtime.


</td></tr>
<tr><td>

[InternalCustomTypeData](./data-schema.internalcustomtypedata.md)


</td><td>


</td></tr>
<tr><td>

[InternalCustomTypeModelFields](./data-schema.internalcustomtypemodelfields.md)


</td><td>


</td></tr>
<tr><td>

[InternalModel](./data-schema.internalmodel.md)


</td><td>

Internal representation of Model Type that exposes the `data` property. Used at buildtime.


</td></tr>
<tr><td>

[InternalModelData](./data-schema.internalmodeldata.md)


</td><td>


</td></tr>
<tr><td>

[InternalModelFields](./data-schema.internalmodelfields.md)


</td><td>


</td></tr>
<tr><td>

[InternalModelIndexType](./data-schema.internalmodelindextype.md)


</td><td>


</td></tr>
<tr><td>

[InternalRef](./data-schema.internalref.md)


</td><td>

Internal representation of Ref that exposes the `data` property. Used at buildtime.


</td></tr>
<tr><td>

[InternalRelationalField](./data-schema.internalrelationalfield.md)


</td><td>

Internal representation of Model Field that exposes the `data` property. Used at buildtime.


</td></tr>
<tr><td>

[InternalSchema](./data-schema.internalschema.md)


</td><td>


</td></tr>
<tr><td>

[InternalSchemaModels](./data-schema.internalschemamodels.md)


</td><td>


</td></tr>
<tr><td>

[InternalSubscriptionSource](./data-schema.internalsubscriptionsource.md)


</td><td>


</td></tr>
<tr><td>

[Intersection](./data-schema.intersection.md)


</td><td>


</td></tr>
<tr><td>

[IsAny](./data-schema.isany.md)


</td><td>


</td></tr>
<tr><td>

[IsEmptyStringOrNever](./data-schema.isemptystringornever.md)


</td><td>


</td></tr>
<tr><td>

[IsFalse](./data-schema.isfalse.md)


</td><td>


</td></tr>
<tr><td>

[IsRefRequired](./data-schema.isrefrequired.md)


</td><td>


</td></tr>
<tr><td>

[IsRequired](./data-schema.isrequired.md)


</td><td>


</td></tr>
<tr><td>

[IsTrue](./data-schema.istrue.md)


</td><td>


</td></tr>
<tr><td>

[Json](./data-schema.json.md)


</td><td>


</td></tr>
<tr><td>

[JsResolver](./data-schema.jsresolver.md)


</td><td>


</td></tr>
<tr><td>

[JsResolverEntry](./data-schema.jsresolverentry.md)


</td><td>


</td></tr>
<tr><td>

[KindaPretty](./data-schema.kindapretty.md)


</td><td>

Prettify without rewriting function types.


</td></tr>
<tr><td>

[LambdaFunctionDefinition](./data-schema.lambdafunctiondefinition.md)


</td><td>


</td></tr>
<tr><td>

[LambdaReturnType](./data-schema.lambdareturntype.md)


</td><td>

Returns a return type with lazy loaders removed.

(Custom handlers should not return lazy loaded fields -- they're \*lazy loaded\*.)


</td></tr>
<tr><td>

[LazyLoader](./data-schema.lazyloader.md)


</td><td>


</td></tr>
<tr><td>

[ListOptionsPkParams](./data-schema.listoptionspkparams.md)


</td><td>

Models with composite PKs defined are expected to contain the model's pk, sk, and sortDirection properties in the `options` param


</td></tr>
<tr><td>

[ListReturnValue](./data-schema.listreturnvalue.md)


</td><td>


</td></tr>
<tr><td>

[methodKeyOf](./data-schema.methodkeyof.md)


</td><td>


</td></tr>
<tr><td>

[MinusReadonly](./data-schema.minusreadonly.md)


</td><td>


</td></tr>
<tr><td>

[ModelData](./data-schema.modeldata.md)


</td><td>


</td></tr>
<tr><td>

[ModelDefaultIdentifier](./data-schema.modeldefaultidentifier.md)


</td><td>


</td></tr>
<tr><td>

[ModelField](./data-schema.modelfield.md)


</td><td>

Public API for the chainable builder methods exposed by Model Field. The type is narrowing e.g., after calling .array() it will be omitted from intellisense suggestions


</td></tr>
<tr><td>

[ModelFields](./data-schema.modelfields.md)


</td><td>


</td></tr>
<tr><td>

[ModelFieldTypeParamInner](./data-schema.modelfieldtypeparaminner.md)


</td><td>


</td></tr>
<tr><td>

[ModelFieldTypeParamOuter](./data-schema.modelfieldtypeparamouter.md)


</td><td>


</td></tr>
<tr><td>

[ModelIdentifier](./data-schema.modelidentifier.md)


</td><td>


</td></tr>
<tr><td>

[ModelIndexData](./data-schema.modelindexdata.md)


</td><td>


</td></tr>
<tr><td>

[ModelIndexType](./data-schema.modelindextype.md)


</td><td>


</td></tr>
<tr><td>

[ModelIndexTypeShape](./data-schema.modelindextypeshape.md)


</td><td>


</td></tr>
<tr><td>

[ModelPath](./data-schema.modelpath.md)


</td><td>

Generates custom selection set type with up to 6 levels of nested fields


</td></tr>
<tr><td>

[ModelPrimaryCompositeKeyInput](./data-schema.modelprimarycompositekeyinput.md)


</td><td>

A composite SK (in an identifier or secondaryIndex) resolves to this type for list queries and index queries


</td></tr>
<tr><td>

[ModelRelationalField](./data-schema.modelrelationalfield.md)


</td><td>


</td></tr>
<tr><td>

[ModelRelationalFieldData](./data-schema.modelrelationalfielddata.md)


</td><td>


</td></tr>
<tr><td>

[ModelRelationalFieldFunctions](./data-schema.modelrelationalfieldfunctions.md)


</td><td>


</td></tr>
<tr><td>

[ModelRelationalFieldParamShape](./data-schema.modelrelationalfieldparamshape.md)


</td><td>


</td></tr>
<tr><td>

[ModelRelationalTypeArgFactory](./data-schema.modelrelationaltypeargfactory.md)


</td><td>


</td></tr>
<tr><td>

[ModelSchema](./data-schema.modelschema.md)


</td><td>


</td></tr>
<tr><td>

[ModelSchemaContents](./data-schema.modelschemacontents.md)


</td><td>


</td></tr>
<tr><td>

[ModelSchemaParamShape](./data-schema.modelschemaparamshape.md)


</td><td>


</td></tr>
<tr><td>

[ModelSchemaType](./data-schema.modelschematype.md)


</td><td>

Amplify API Next Model Schema shape


</td></tr>
<tr><td>

[ModelSortDirection](./data-schema.modelsortdirection.md)


</td><td>


</td></tr>
<tr><td>

[ModelType](./data-schema.modeltype.md)


</td><td>


</td></tr>
<tr><td>

[ModelTypeParamShape](./data-schema.modeltypeparamshape.md)


</td><td>


</td></tr>
<tr><td>

[ModelTypes](./data-schema.modeltypes.md)


</td><td>


</td></tr>
<tr><td>

[ModelTypesSSRRequest](./data-schema.modeltypesssrrequest.md)


</td><td>


</td></tr>
<tr><td>

[ModelWithRelationships](./data-schema.modelwithrelationships.md)


</td><td>


</td></tr>
<tr><td>

[MutationCustomOperation](./data-schema.mutationcustomoperation.md)


</td><td>


</td></tr>
<tr><td>

[MutationInput](./data-schema.mutationinput.md)


</td><td>

All required fields and relational fields, exclude readonly fields


</td></tr>
<tr><td>

[MutationInputInternal](./data-schema.mutationinputinternal.md)


</td><td>

All required fields and relational fields, exclude readonly fields


</td></tr>
<tr><td>

[MutationOperations](./data-schema.mutationoperations.md)


</td><td>


</td></tr>
<tr><td>

[NestedTypes](./data-schema.nestedtypes.md)


</td><td>


</td></tr>
<tr><td>

[NonEmpty](./data-schema.nonempty.md)


</td><td>


</td></tr>
<tr><td>

[Normalize](./data-schema.normalize.md)


</td><td>

Removes `null | undefined` from the return type if the operation is a subscription, since subs don't fire on empty/non-existent values.


</td></tr>
<tr><td>

[Not](./data-schema.not.md)


</td><td>


</td></tr>
<tr><td>

[NotAny](./data-schema.notany.md)


</td><td>


</td></tr>
<tr><td>

[NotEqual](./data-schema.notequal.md)


</td><td>


</td></tr>
<tr><td>

[Nullable](./data-schema.nullable.md)


</td><td>

Field type arg mutators


</td></tr>
<tr><td>

[NumericFilter](./data-schema.numericfilter.md)


</td><td>


</td></tr>
<tr><td>

[ObjectFromEntries](./data-schema.objectfromentries.md)


</td><td>

Turns this:

```ts
type E = [
 ['keyA', 'valueA'],
 ['keyB', 'valueB'],
 ['keyC', 'valueC'],
]
```
Into this:

```ts
type O = {
 keyA: "valueA",
 keyB: "valueB",
 keyC: "valueC",
}
```


</td></tr>
<tr><td>

[ObjectIsNonEmpty](./data-schema.objectisnonempty.md)


</td><td>


</td></tr>
<tr><td>

[ObservedReturnValue](./data-schema.observedreturnvalue.md)


</td><td>


</td></tr>
<tr><td>

[ObserveQueryReturnValue](./data-schema.observequeryreturnvalue.md)


</td><td>


</td></tr>
<tr><td>

[OmitFromEach](./data-schema.omitfromeach.md)


</td><td>


</td></tr>
<tr><td>

[Operation](./data-schema.operation.md)


</td><td>


</td></tr>
<tr><td>

[OwnerField](./data-schema.ownerfield.md)


</td><td>


</td></tr>
<tr><td>

[OwnerProviders](./data-schema.ownerproviders.md)


</td><td>


</td></tr>
<tr><td>

[Prettify](./data-schema.prettify.md)


</td><td>


</td></tr>
<tr><td>

[PrimaryIndexFieldsToIR](./data-schema.primaryindexfieldstoir.md)


</td><td>


</td></tr>
<tr><td>

[PrivateProvider](./data-schema.privateprovider.md)


</td><td>


</td></tr>
<tr><td>

[Provider](./data-schema.provider.md)


</td><td>


</td></tr>
<tr><td>

[PublicProvider](./data-schema.publicprovider.md)


</td><td>


</td></tr>
<tr><td>

[QueryCustomOperation](./data-schema.querycustomoperation.md)


</td><td>


</td></tr>
<tr><td>

[QueryFieldLabelFromTuple](./data-schema.queryfieldlabelfromtuple.md)


</td><td>


</td></tr>
<tr><td>

[RDSModelSchema](./data-schema.rdsmodelschema.md)


</td><td>


</td></tr>
<tr><td>

[RDSModelSchemaFunctions](./data-schema.rdsmodelschemafunctions.md)


</td><td>


</td></tr>
<tr><td>

[RDSModelSchemaParamShape](./data-schema.rdsmodelschemaparamshape.md)


</td><td>


</td></tr>
<tr><td>

[RDSSchemaBrand](./data-schema.rdsschemabrand.md)


</td><td>


</td></tr>
<tr><td>

[RefType](./data-schema.reftype.md)


</td><td>


</td></tr>
<tr><td>

[RefTypeArgFactory](./data-schema.reftypeargfactory.md)


</td><td>


</td></tr>
<tr><td>

[RefTypeData](./data-schema.reftypedata.md)


</td><td>


</td></tr>
<tr><td>

[RefTypeParamShape](./data-schema.reftypeparamshape.md)


</td><td>


</td></tr>
<tr><td>

[RelationshipTemplate](./data-schema.relationshiptemplate.md)


</td><td>


</td></tr>
<tr><td>

[RelationshipTypes](./data-schema.relationshiptypes.md)


</td><td>


</td></tr>
<tr><td>

[RelationTypeFunctionOmitMapping](./data-schema.relationtypefunctionomitmapping.md)


</td><td>


</td></tr>
<tr><td>

[RemapCustomOperation](./data-schema.remapcustomoperation.md)


</td><td>


</td></tr>
<tr><td>

[RemapCustomType](./data-schema.remapcustomtype.md)


</td><td>


</td></tr>
<tr><td>

[RemapEnum](./data-schema.remapenum.md)


</td><td>


</td></tr>
<tr><td>

[RemapModel](./data-schema.remapmodel.md)


</td><td>


</td></tr>
<tr><td>

[RenameUsingTuples](./data-schema.renameusingtuples.md)


</td><td>

Renames keys of an object using renaming tuples. E.g.,

Using this object:

```ts
type O = {
 keyA: A,
 keyB: B,
 keyC: C,
}
```
And this rename map:

```ts
type R = [
 ['keyA', 'renamedA'],
 ['keyB', 'renamedB'],
 ['keyC', 'renamedC'],
]
```
Produce this:

```ts
type Renamed = {
 renamedA: A,
 renamedB: B,
 renamedC: C,
}
```


</td></tr>
<tr><td>

[RequestOptions](./data-schema.requestoptions.md)


</td><td>

Request options that are passed to custom header functions. `method` and `headers` are not included in custom header functions passed to subscriptions.


</td></tr>
<tr><td>

[Required\_2](./data-schema.required_2.md)


</td><td>


</td></tr>
<tr><td>

[ResolvedSortKeyFields](./data-schema.resolvedsortkeyfields.md)


</td><td>


</td></tr>
<tr><td>

[ResolveFieldRequirements](./data-schema.resolvefieldrequirements.md)


</td><td>


</td></tr>
<tr><td>

[ResolveFields](./data-schema.resolvefields.md)


</td><td>

Takes a `ReturnType<typeof a.model()>` and turns it into a client-consumable type. Fields definitions (e.g., `a.string()`<!-- -->) are turned into the client facing types (e.g., `string`<!-- -->), `a.ref()` fields will be resolved, and relationships (e.g., `a.belongsTo()`<!-- -->) will be turned into `LazyLoader` fields (e.g., `post.comments({...})`<!-- -->).

The first type parameter (`Bag`<!-- -->) should always just be the top-level `ClientSchema` that references and related model definitions can be resolved against.


</td></tr>
<tr><td>

[ResolveIdentifierFields](./data-schema.resolveidentifierfields.md)


</td><td>


</td></tr>
<tr><td>

[ResolveIndividualField](./data-schema.resolveindividualfield.md)


</td><td>


</td></tr>
<tr><td>

[ResolveRef](./data-schema.resolveref.md)


</td><td>

Dereferences an `a.ref()` against a given "bag" of independently resolved types.

This util will examine the ref for requiredness and array-ness and wrap/augment to referred-to type accordingly.


</td></tr>
<tr><td>

[ResolveRefValueArrayTraits](./data-schema.resolverefvaluearraytraits.md)


</td><td>

Converts the resolved RefType Value type into Array<!-- -->&lt;<!-- -->&gt; according to the `array` and `arrayRequired` properties of the RefType


</td></tr>
<tr><td>

[ResolveRelationship](./data-schema.resolverelationship.md)


</td><td>


</td></tr>
<tr><td>

[ResourceAuthorization](./data-schema.resourceauthorization.md)


</td><td>


</td></tr>
<tr><td>

[ResourceAuthorizationData](./data-schema.resourceauthorizationdata.md)


</td><td>


</td></tr>
<tr><td>

[ResourceOperation](./data-schema.resourceoperation.md)


</td><td>


</td></tr>
<tr><td>

[satisfy](./data-schema.satisfy.md)


</td><td>


</td></tr>
<tr><td>

[SchemaAuthorization](./data-schema.schemaauthorization.md)


</td><td>

Super-set of regular auth type; includes schema-level resource access configuration


</td></tr>
<tr><td>

[SchemaConfiguration](./data-schema.schemaconfiguration.md)


</td><td>


</td></tr>
<tr><td>

[SchemaContent](./data-schema.schemacontent.md)


</td><td>


</td></tr>
<tr><td>

[SchemaModelType](./data-schema.schemamodeltype.md)


</td><td>

External representation of Model Type that exposes the `relationships` modifier. Used on the complete schema object.


</td></tr>
<tr><td>

[SchemaReturnType](./data-schema.schemareturntype.md)


</td><td>


</td></tr>
<tr><td>

[SecondaryIndexIrShape](./data-schema.secondaryindexirshape.md)


</td><td>

SecondaryIndex index types and query methods


</td></tr>
<tr><td>

[SecondaryIndexToIR](./data-schema.secondaryindextoir.md)


</td><td>

Maps array of ModelIndexType to SecondaryIndexIrShape (defined in in data-schema-types)


</td></tr>
<tr><td>

[Select](./data-schema.select.md)


</td><td>


</td></tr>
<tr><td>

[SelectionSet](./data-schema.selectionset.md)


</td><td>


</td></tr>
<tr><td>

[SetTypeSubArg](./data-schema.settypesubarg.md)


</td><td>

Replaces the value of a key in a complex generic type param


</td></tr>
<tr><td>

[ShallowPretty](./data-schema.shallowpretty.md)


</td><td>


</td></tr>
<tr><td>

[SingleIndexIrFromType](./data-schema.singleindexirfromtype.md)


</td><td>


</td></tr>
<tr><td>

[SingularReturnValue](./data-schema.singularreturnvalue.md)


</td><td>


</td></tr>
<tr><td>

[SizeFilter](./data-schema.sizefilter.md)


</td><td>

Filter options that can be used on fields where size checks are supported.


</td></tr>
<tr><td>

[SpreadTuple](./data-schema.spreadtuple.md)


</td><td>

Transform into the type intersection of all items in a given tuple


</td></tr>
<tr><td>

[SqlReferenceHandler](./data-schema.sqlreferencehandler.md)


</td><td>


</td></tr>
<tr><td>

[SqlReferenceHandlerData](./data-schema.sqlreferencehandlerdata.md)


</td><td>


</td></tr>
<tr><td>

[SqlStatementFolderEntry](./data-schema.sqlstatementfolderentry.md)


</td><td>


</td></tr>
<tr><td>

[Strategy](./data-schema.strategy.md)


</td><td>


</td></tr>
<tr><td>

[StringFilter](./data-schema.stringfilter.md)


</td><td>

Filters options that can be used on string-like fields.


</td></tr>
<tr><td>

[SubscriptionCustomOperation](./data-schema.subscriptioncustomoperation.md)


</td><td>


</td></tr>
<tr><td>

[SubscriptionSource](./data-schema.subscriptionsource.md)


</td><td>


</td></tr>
<tr><td>

[SystemFields](./data-schema.systemfields.md)


</td><td>


</td></tr>
<tr><td>

[UnionToIntersection](./data-schema.uniontointersection.md)


</td><td>


</td></tr>
<tr><td>

[UnwrapArray](./data-schema.unwraparray.md)


</td><td>


</td></tr>
<tr><td>

[UpdateModelInput](./data-schema.updatemodelinput.md)


</td><td>


</td></tr>
<tr><td>

[UsableModelFieldKey](./data-schema.usablemodelfieldkey.md)


</td><td>


</td></tr>
<tr><td>

[UsableModelTypeKey](./data-schema.usablemodeltypekey.md)


</td><td>


</td></tr>
<tr><td>

[WithNullablesAsOptionalRecursively](./data-schema.withnullablesasoptionalrecursively.md)


</td><td>


</td></tr>
<tr><td>

[WritableKeys](./data-schema.writablekeys.md)


</td><td>


</td></tr>
<tr><td>

[WritableKeysInternal](./data-schema.writablekeysinternal.md)


</td><td>


</td></tr>
</tbody></table>
